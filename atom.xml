<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>罗宾的木屋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-28T07:55:35.282Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Robin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac pro上网满解决方案</title>
    <link href="http://yoursite.com/2018/05/28/mac-network/"/>
    <id>http://yoursite.com/2018/05/28/mac-network/</id>
    <published>2018-05-28T07:48:10.000Z</published>
    <updated>2018-05-28T07:55:35.282Z</updated>
    
    <content type="html"><![CDATA[<p>Mac最近上网很慢, 慢到令人发指, 刚买的新路由器也不行, 感觉不对, 就在网上找解决方案, 还真好到一个有用<br>的, 但是, 我很无语:<br>在“系统偏好设置”－“网络”－打开“位置”－“编辑位置”－点“➕”－随便编一个名字－确定，改自动为你刚才添加的那个网络。<br><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=575b64d9a486c91708565a3ff90d5cf7/2fdda3cc7cd98d10c3788c10223fb80e7bec9067.jpg" alt=""><br>效果不错, 居然还有这操作!<br><a href="https://blog.csdn.net/prliu/article/details/53945462" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac最近上网很慢, 慢到令人发指, 刚买的新路由器也不行, 感觉不对, 就在网上找解决方案, 还真好到一个有用&lt;br&gt;的, 但是, 我很无语:&lt;br&gt;在“系统偏好设置”－“网络”－打开“位置”－“编辑位置”－点“➕”－随便编一个名字－确定，改自动为你刚才添加的那个网络。&lt;
      
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/categories/Mac/"/>
    
    
      <category term="上网" scheme="http://yoursite.com/tags/%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>获取Production下的APNS deviceToken</title>
    <link href="http://yoursite.com/2018/05/07/ios-deviceToken-Production/"/>
    <id>http://yoursite.com/2018/05/07/ios-deviceToken-Production/</id>
    <published>2018-05-07T09:13:06.000Z</published>
    <updated>2018-05-07T09:24:44.063Z</updated>
    
    <content type="html"><![CDATA[<ol><li>首先在你的代码中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</span><br></pre></td></tr></table></figure></li></ol><p>添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let deviceToken_ns = NSData.init(data: deviceToken);    // 转换成NSData类型</span><br><span class="line">        var token = deviceToken_ns.description.trimmingCharacters(in: CharacterSet(charactersIn: &quot;&lt;&gt;&quot;));</span><br><span class="line">        token = token.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;)        </span><br><span class="line">        NSLog(&quot;\n&gt;&gt;&gt;[DeviceToken Success]:%@\n\n&quot;,token);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>将你的code打包一个ipa的adhoc包出来</li><li><p>将ipa安装到你的手机上</p><blockquote><p>安装方法博客里有</p></blockquote></li><li><p><code>Xcode</code> -&gt; <code>Window</code> -&gt; <code>Devices and Simulators</code></p></li><li>在左侧<code>Connected</code>下找到安装ipa的设备并选中</li><li>右侧将出现iPhone的摘要信息, 点击<code>Open Console</code>按钮</li><li>在弹出的控制台中, 左侧<code>设备</code>区域会显示自己的设备, 选中设备</li><li>在右上角搜索框中, 搜索<code>DeviceToken Success</code></li><li>Got it</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;首先在你的代码中&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>如何安装ipa</title>
    <link href="http://yoursite.com/2018/05/07/ios-install-ipa/"/>
    <id>http://yoursite.com/2018/05/07/ios-install-ipa/</id>
    <published>2018-05-07T08:40:52.000Z</published>
    <updated>2018-05-07T09:25:08.213Z</updated>
    
    <content type="html"><![CDATA[<p>最新版的iTunes中, Apple爸爸移除了Application, 要逼着苦逼的程序员用TestFlight, 可TestFlight<br>有时候真心感觉坑爹啊, 感觉相当麻烦, 作为比较懒的程序员, 我们在偷懒的路上, 永远不会停下来, So, 以下的几个方法, 依然让我们可以很愉快的玩耍.</p><h3 id="方法一-Apple-Configurator-2"><a href="#方法一-Apple-Configurator-2" class="headerlink" title="方法一: Apple Configurator 2."></a>方法一: Apple Configurator 2.</h3><p>话说Apple Configurator 2, 在此之前从未听说过, 其实和iTunes安装ipa差不多</p><ol><li>打开 App Store, 下载 <a href="https://itunes.apple.com/us/app/apple-configurator-2/id1037126344?mt=12" target="_blank" rel="noopener">Apple Configurator 2</a><br><img src="https://cdn-images-1.medium.com/max/1600/1*vXL0GyoutQo6VewSvrt0Mw.png" alt=""></li><li>将您的设备通过USB连接到电脑上, 打开Apple Configurator 2, 将看到类似的页面:<br><img src="https://cdn-images-1.medium.com/max/1600/1*_sD3HYG0bo51i6rFJe3FtQ.png" alt=""></li><li>选中自己的设备, 点击”添加”按钮<br><img src="https://cdn-images-1.medium.com/max/1600/1*BufsahDXqkQH3YXQVN2jxQ.png" alt=""></li><li>在下拉列表中选择”应用”<br><img src="https://cdn-images-1.medium.com/max/1600/1*BufsahDXqkQH3YXQVN2jxQ.png" alt=""></li><li>在弹出的对话框中点击”从我的Mac选取…”<br><img src="https://cdn-images-1.medium.com/max/1600/1*h1-tVdVjLAR-ZMY-PQTgrw.png" alt=""></li><li>在浏览窗口中找到要安装的ipa<br><img src="https://cdn-images-1.medium.com/max/1600/1*JYVDVEQ8yAq-_PyP3p9xIA.png" alt=""></li><li>Apple Configurator将ipa安装到你的设备上<br><img src="https://cdn-images-1.medium.com/max/1600/1*2yP_64L9dA-IRMk9xK0G4Q.png" alt=""></li><li>完了</li></ol><h3 id="方法二-iTunes添加Ad-Hoc-Build"><a href="#方法二-iTunes添加Ad-Hoc-Build" class="headerlink" title="方法二: iTunes添加Ad Hoc Build"></a>方法二: iTunes添加Ad Hoc Build</h3><ol><li>导出一个Ad Hoc Build IPA 包</li><li>打开iTunes, 直接把ipa拖到左侧Devices区域下的相应设备中<br><img src="https://cdn-images-1.medium.com/max/1600/1*3E_ugeZqaBQSA3DKVIFqNw.png" alt=""></li><li>完了<blockquote><p>苹果爸爸 你在逗我吗?</p></blockquote></li></ol><h3 id="方法三-Xcode"><a href="#方法三-Xcode" class="headerlink" title="方法三: Xcode"></a>方法三: Xcode</h3><ol><li>打开 Xcode , 找到Window -&gt; Devices and Simulators</li><li>选中要安装ipa的设备<br><img src="https://cdn-images-1.medium.com/max/1600/1*IRtzoQ8Yr27C8X-REGDTyw.png" alt=""></li><li>将ipa拖拽到 ‘INSTALLED APPS’区域<br><img src="https://cdn-images-1.medium.com/max/1600/1*izCqEdKddD0B6AoMLVcJww.png" alt=""></li><li>等待安装完成<br><img src="https://cdn-images-1.medium.com/max/1600/1*Sb3QiQelnNVp233p7qgpRw.png" alt=""></li><li>完了</li></ol><p><a href="https://codeburst.io/latest-itunes-12-7-removed-the-apps-option-how-to-install-ipa-on-the-device-3c7d4a2bc788" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最新版的iTunes中, Apple爸爸移除了Application, 要逼着苦逼的程序员用TestFlight, 可TestFlight&lt;br&gt;有时候真心感觉坑爹啊, 感觉相当麻烦, 作为比较懒的程序员, 我们在偷懒的路上, 永远不会停下来, So, 以下的几个方法, 依
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 中的元类 (meta-class)</title>
    <link href="http://yoursite.com/2018/04/25/objc-meta-class/"/>
    <id>http://yoursite.com/2018/04/25/objc-meta-class/</id>
    <published>2018-04-25T06:42:46.000Z</published>
    <updated>2018-04-25T07:50:38.132Z</updated>
    
    <content type="html"><![CDATA[<p>通常的开发过程中, 我们很少接触到元类的概念, 基本上用不到, 但是, 对于Objective-C运行时的理解上,是需要对元类有所了解的.</p><p>OC源于C语言, 同时结合了SmallTalk的面向语言的特性, 最终变成我们今天看到的样子, 关于OC 和Smalltalk的关系, 可以看<a href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/" target="_blank" rel="noopener">这里</a>, OC的底层还是C, 只是在编译的时候, 编译器会把我们的OC语法重新转换成C的语法.</p><p>C是静态语言, 换言之, 调用什么方法是在编译阶段确定的.<br>OC是动态语言, 编译工程只能确定要发送的消息, 具体如何响应, 需要由运行时检查相关实例所属的类, 并在方法列表中检索出具体实现, 然后做出响应.(这就是OC的消息发送机制, 为什么叫发消息, 不叫调函数)</p><p>###在运行时创建一个类<br>我们用运行时创建一个NSError的子类, 并添加一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class newClass =</span><br><span class="line">    objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0);</span><br><span class="line">class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;);</span><br><span class="line">objc_registerClassPair(newClass);</span><br></pre></td></tr></table></figure></p><p>并添加一个<code>ReportFunction</code>的函数作为实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void ReportFunction(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]);</span><br><span class="line"></span><br><span class="line">    Class currentClass = [self class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中, 用运行时创建一个类, 总共用了三步:</p><ol><li>为”class pair”（类对）分配空间（使用 objc_allocateClassPair ）</li><li>添加类中所需的方法和变量（这里使用 class_addMethod 添加了一个方法）</li><li>注册这个类使其能够被使用（使用 objc_registerClassPair ）</li></ol><blockquote><p>之所以叫类对, 原因是返回一个类, 同时创建相关元类, 只是不用返回</p></blockquote><p>###数据结果如何才能成为一个对象<br>每个对象都必须有所属的类, 这是面向对象概念的基本原则(万物皆对象), 对于OC页同样适用. 任何数据结构只要包含一个正确指向类的指针皆可称谓对象.<br>在OC中, 一个对象的类是有一个<code>isa</code>指针确定的. <code>isa</code>指向实例的类.</p><p>OC中最根本的对象定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">@interface Object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>换言之, 所有以一个指向<code>isa_t</code>指针开始的数据结构, 都可以认为是<code>objc_object</code></p><blockquote><p>现在isa的类型变成了 isa_t 类型而不是 Class类型, 所里这里直接采用最新的定义方式</p></blockquote><p>OC中的对象一个重要特点就是可以向他们发送消息(不是直接调用他们的函数):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@&quot;stringValue&quot;</span><br><span class="line">    writeToFile:@&quot;/file.txt&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL];</span><br></pre></td></tr></table></figure></p><p>当你发送一个消息给OC的对象时（就像这里的 NSCFString），运行时会根据对象的isa指针获取到对象的类（这里是 NSCFString 类）。类包含了一串方法能够被这个类的所有实例对象使用，并且有一个 superclass的指针来查找继承链中的方法。运行时在类和父类的方法列表中查找能够匹配这个消息的 selector（在上面的例子中，是在 NSString 类中的 writeToFile:atomically:encoding:error 方法）。然后运行时唤起这个方法的实现(IMP)。</p><p><strong>重点是<code>Class</code>定义了你可以向其对象发送的消息</strong></p><h3 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h3><p>此刻, 你应该可以理解在OC中<code>Class</code>其实也是一种对象, 这就意味着你可以像<code>Class</code>发送消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStringEncoding defaultStringEncoding = [NSString defaultStringEncoding];</span><br></pre></td></tr></table></figure></p><p>在这个例子中, <code>defaultStringEncoding</code>就是发送给<code>NSString</code>class的消息<br>由于<code>Class</code>是一种对象, 意味着<code>Class</code>必然包含一个<code>isa</code>指针,以便于和<code>objc_object</code>兼容,objc_class的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了调用一个类方法, 类的<code>isa</code>必须指向一个<code>Class</code>数据结构, 并且这个类结构必须包含一个方法列表使我们能够对类使用。<br>这就引导出元类的定义： 元类是一个类对象的类。</p><p>简而言之：<br>当你向一个对象发送一条消息的时候，运行时会在对象的类的方法列表中查找这条消息是否存在。<br>当你向一个类发送一条消息的时候，运行时会在类的元类的方法列表中查找这条消息是否存在。</p><p>元类的存在是必需的，因为他存储了一个类的所有类方法。每个类的元类都是独一无二的，因为每个类都有一系列独特的类方法。</p><p>什么是元类的类</p><p>元类，和类一样，也是一个对象。这表示你能够对元类调用方法。自然的，这表示他必须也有一个类指针。</p><p>所有元类使用基类的元类（即继承链顶端的类的元类）作为他们的类，而所有类的基类都是 NSObject（大多数类是这样的），所以大多数元类使用 NSObject 的元类作为他的类。</p><p>根据规则所有元类使用基类的元类作为他们的类，那么基类的元类就是他自己的类（他们的isa指针指向了自己）。这表明NSObject的元类的指针指向的是他自己（他是一个他自己的实例）。</p><p>继承类和元类</p><p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。<br>这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己。<br>这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p><p>所有实例、类和元类都在 NSObject 的层级下，这表明所有 NSObject 的实例方法都能够被使用，同样的，对类以及元类来说，所有 NSObject 的类方法也是有效的。<br><img src="https://upload-images.jianshu.io/upload_images/1839216-afaaf3d695470e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625" alt=""></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>稍微修改上边的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self makeClass];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)makeClass &#123;</span><br><span class="line">    Class newClass =</span><br><span class="line">    objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0);</span><br><span class="line">    class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;);</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">    id instanceOfNewClass =</span><br><span class="line">    [[newClass alloc] initWithDomain:@&quot;someDomain&quot; code:0 userInfo:nil];</span><br><span class="line">    [instanceOfNewClass performSelector:@selector(report)];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ReportFunction(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;%@ Class is %@, and super is %@.&quot;,object_getClass(self), [self class], [self superclass]);</span><br><span class="line"></span><br><span class="line">    Class currentClass = [self class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %p ---  class %@&quot;, i, currentClass, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>获取一个对象的类：ReportFunction 使用 object_getClass 来跟踪 isa 指针，因为 isa 指针是类结构中被保护的成员（你不能直接访问对象的 isa 指针）。ReportFunction 没有使用一个类方法来做这些，是因为对一个类对象调用类方法不会返回元类，取而代之的是又返回了这个类（所以 [NSString class] 将返回 NSString 的类而不是 NSString 元类）。</p></blockquote><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">This object is 0x6000004499f0.</span><br><span class="line">RuntimeErrorSubclass Class is RuntimeErrorSubclass, and super is NSError.</span><br><span class="line">Following the isa pointer 1 times gives 0x600000449a50 ---  class RuntimeErrorSubclass</span><br><span class="line">Following the isa pointer 2 times gives 0x600000449db0 ---  class RuntimeErrorSubclass</span><br><span class="line">Following the isa pointer 3 times gives 0x101d41e58 ---  class NSObject</span><br><span class="line">Following the isa pointer 4 times gives 0x101d41e58 ---  class NSObject</span><br><span class="line">NSObject&apos;s class is 0x101d41ea8</span><br><span class="line">NSObject&apos;s meta class is 0x101d41e58</span><br></pre></td></tr></table></figure></p><p>看一下isa所指向的地址的值：</p><ul><li>instanceOfNewClass实例对象的地址： 0x6000004499f0</li><li>instanceOfNewClass 的类的地址： 0x600000449a50</li><li>RuntimeErrorSubclass 的元类的地址： 0x600000449db0</li><li>RuntimeErrorSubclass 的元类的类的地址： 0x101d41e58 (即NSObject的元类地址)</li><li>NSObject 元类的类就是 NSObject 的元类（地址相同）</li></ul><p>地址的值并不是主要的，但是他体现了之前我们所描述的从类到元类，再到NSObject元类的整个进度。</p><p>总结：</p><ul><li><p>元类是一个类对象的类。每一个类有他自己独一无二的元类（因为每个类能够有自己独一无二的方法列表）。这就意味着类对象的类并不是和他们一样的类。</p></li><li><p>元类能确保类对象有所有底层类的实例和类方法，中间加上所有自己的类方法。所有类继承自NSObject，这意味着NSObject所有的实例和协议方法为所有类（和元类）对象都定义了。</p></li><li><p>所有元类使用基类的元类（NSObject 元类）来作为他们的类，包括只在运行时自定义的类的元类。</p></li></ul><p>参考: <a href="https://www.jianshu.com/p/79b06fabb459" target="_blank" rel="noopener">浅谈 Objective-C 中的元类 (meta-class)</a></p><p><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html#" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></p><blockquote><p>原谅我的懒惰, 有些文字是直接拷贝的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常的开发过程中, 我们很少接触到元类的概念, 基本上用不到, 但是, 对于Objective-C运行时的理解上,是需要对元类有所了解的.&lt;/p&gt;
&lt;p&gt;OC源于C语言, 同时结合了SmallTalk的面向语言的特性, 最终变成我们今天看到的样子, 关于OC 和Smallt
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS, runtime" scheme="http://yoursite.com/tags/iOS-runtime/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://yoursite.com/2018/04/24/len-of-substring-without-repeate/"/>
    <id>http://yoursite.com/2018/04/24/len-of-substring-without-repeate/</id>
    <published>2018-04-24T08:11:13.000Z</published>
    <updated>2018-04-24T09:28:49.654Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p>示例：</p><p>给定 <code>&quot;abcabcbb&quot;</code> ，没有重复字符的最长子串是 <code>&quot;abc&quot;</code> ，那么长度就是3。</p><p>给定 <code>&quot;bbbbb&quot;</code> ，最长的子串就是 “b” ，长度是1。</p><p>给定 <code>&quot;pwwkew&quot;</code> ，最长子串是 <code>&quot;wke&quot;</code> ，长度是3。请注意答案必须是一个子串，<code>&quot;pwke&quot;</code> 是 子序列  而不是子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;</span><br><span class="line">      let len = s.count</span><br><span class="line">      var ans = 0</span><br><span class="line"></span><br><span class="line">      var dic: [Character : Int] = [:]</span><br><span class="line">      var index = 0 // 默认长度</span><br><span class="line">      for i in 0 ..&lt; len &#123;</span><br><span class="line">          let current = s.index(s.startIndex, offsetBy: i)</span><br><span class="line">          let char = s[current]</span><br><span class="line">          if let order = dic[char] &#123;</span><br><span class="line">              index = max(order, index)</span><br><span class="line">          &#125;</span><br><span class="line">          ans = max(i - index + 1, ans) // 计算长度</span><br><span class="line">          dic[char] = i + 1 // 保存当前长度</span><br><span class="line">      &#125;</span><br><span class="line">      return ans</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;给定 &lt;code&gt;&amp;quot;abcabcbb&amp;quot;&lt;/code&gt; ，没有重复字符的最长子串是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; ，那么长度就是3。&lt;/p
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>存在重复</title>
    <link href="http://yoursite.com/2018/04/23/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D/"/>
    <id>http://yoursite.com/2018/04/23/存在重复/</id>
    <published>2018-04-23T11:50:11.000Z</published>
    <updated>2018-04-23T11:50:37.848Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使 nums [i] = nums [j]，并且 i 和 j 的绝对差值最大为 k。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func containsNearbyDuplicate(_ nums: [Int], _ k: Int) -&gt; Bool &#123;</span><br><span class="line">      var set = Set&lt;Int&gt;()</span><br><span class="line">        for i in 0..&lt;nums.count &#123;</span><br><span class="line">            if i &gt; k &#123;</span><br><span class="line">                set.remove(nums[i-k-1])</span><br><span class="line">            &#125;</span><br><span class="line">            let (result,_) = set.insert(nums[i])</span><br><span class="line">            if !result &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使 nums [i] = nums [j]，并且 i 和 j 的绝对差值最大为 k。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>宝石与石头</title>
    <link href="http://yoursite.com/2018/04/23/%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
    <id>http://yoursite.com/2018/04/23/宝石与石头/</id>
    <published>2018-04-23T11:45:35.000Z</published>
    <updated>2018-04-23T11:48:46.272Z</updated>
    
    <content type="html"><![CDATA[<p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><p>注意:</p><p>S 和 J 最多含有50个字母。<br>J 中的字符不重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func numJewelsInStones(_ J: String, _ S: String) -&gt; Int &#123;</span><br><span class="line">       var count = 0</span><br><span class="line">        for  j in J &#123;</span><br><span class="line">            for s in S &#123;</span><br><span class="line">                if s == j &#123;</span><br><span class="line">                    count += 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;p&gt;J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Javascript</title>
    <link href="http://yoursite.com/2018/04/23/Javascript/"/>
    <id>http://yoursite.com/2018/04/23/Javascript/</id>
    <published>2018-04-23T04:11:59.000Z</published>
    <updated>2018-04-23T09:44:38.343Z</updated>
    
    <content type="html"><![CDATA[<div class="slides" style="  position: relative;  padding-bottom: 56.25%;  padding-top: 35px;  height: 0;  overflow: hidden;">  <iframe src="https://wickso.me/2016/04/12/generic/" width="800" height="600" frameborder="0" allowfullscreen style="    position: absolute;    top:0;    left: 0;    width: 100%;    height: 100%;  "></iframe></div><div class="slides" style="  position: relative;  padding-bottom: 56.25%;  padding-top: 35px;  height: 0;  overflow: hidden;">  <iframe src="http://yangyunhe.gitee.io/my_blog/code_page/es6-ppt/index.html" width="800" height="600" frameborder="0" allowfullscreen style="    position: absolute;    top:0;    left: 0;    width: 100%;    height: 100%;  "></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;slides&quot; style=&quot;
  position: relative;
  padding-bottom: 56.25%;
  padding-top: 35px;
  height: 0;
  overflow: hidden;
&quot;&gt;
  &lt;ifra
      
    
    </summary>
    
      <category term="slide" scheme="http://yoursite.com/categories/slide/"/>
    
    
      <category term="slide" scheme="http://yoursite.com/tags/slide/"/>
    
  </entry>
  
  <entry>
    <title>在iOS中使用pdf文件</title>
    <link href="http://yoursite.com/2018/04/21/pdf-in-iOS/"/>
    <id>http://yoursite.com/2018/04/21/pdf-in-iOS/</id>
    <published>2018-04-21T11:57:17.000Z</published>
    <updated>2018-04-23T12:04:24.232Z</updated>
    
    <content type="html"><![CDATA[<p>安卓上可以很方便的使用svg文件, 但是iOS就是比较苦逼了, 需要转换成png, 或者pdf才能使用.</p><h2 id="Xcode使用pdf的原理"><a href="#Xcode使用pdf的原理" class="headerlink" title="Xcode使用pdf的原理"></a>Xcode使用pdf的原理</h2><p>Xcode在构建项目时会基于Asset Catalog中的PDF矢量图形自动创建@1x、@2x和@3x三种规格的PNG文件. 通常我们会将pdf在 Asset Catalog 中设置Scales属性设置为”Single Scale”</p><p>注意:</p><ul><li>矢量图形的支持只是阶段性的 - 在构建阶段，Xcode会基于PDF生成PNG图片并输出到界面当中。</li><li>一旦完成矢量图形的设置，你就无法为其指定新的输出尺寸了。如果需要更大的规格，则需要创建新的PDF图形，否则在使用AutoLayout时原来的图片会失真。<br>正如前面所说的，iOS 8只能支持基于PDF生成的PNG文件；但OS X却可以真正完整的支持矢量图形，你可以直接通过Auto Layout或代码来缩放矢量图形，不会产生任何失真。</li><li>使用pdf后, 图片显示的大小不一定是按照设计图的大小来显示, 很多情况下需要对图片控件的大小进行修正</li><li>对于UIImageView, UIButton等空间, 我们可以通过置imageEdgeInsets来实际控制图片的显示大小</li><li>对于UITabBarItem这个控件, 系统似乎并没有提供相关api修改图片大小, 这种情况, 只能使用png<h2 id="为什么Xcode不支持svg"><a href="#为什么Xcode不支持svg" class="headerlink" title="为什么Xcode不支持svg:"></a>为什么Xcode不支持svg:</h2></li><li><p>Why PDF instead of SVG or other formats</p></li><li><p>For SVG and other formats, the vector image has no actual size info, while PDF has size info. I think what Xcode 6 does is using the size info in PDF as actual display size, then generate 2x 3x files from the vector image.</p></li></ul><p>因为svg产生的image对象是矢量的, 没有size信息, 而Xcode需要依据pdf的size属性, 将矢量图片转为2x, 3x显示所需要的图形文件</p><p><a href="https://www.jianshu.com/p/e4fe82ca6fd0" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安卓上可以很方便的使用svg文件, 但是iOS就是比较苦逼了, 需要转换成png, 或者pdf才能使用.&lt;/p&gt;
&lt;h2 id=&quot;Xcode使用pdf的原理&quot;&gt;&lt;a href=&quot;#Xcode使用pdf的原理&quot; class=&quot;headerlink&quot; title=&quot;Xcode使
      
    
    </summary>
    
      <category term="Technique" scheme="http://yoursite.com/categories/Technique/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>svg批量转化为pdf</title>
    <link href="http://yoursite.com/2018/04/21/SVG2PDF/"/>
    <id>http://yoursite.com/2018/04/21/SVG2PDF/</id>
    <published>2018-04-21T11:54:00.000Z</published>
    <updated>2018-04-23T12:04:27.342Z</updated>
    
    <content type="html"><![CDATA[<p>程序员都是比较懒的人, 至少我是这样, 把一个svg转成pdf, 我可以在网上找找在线转化, 三个以上, 我就不伺候了, 就要找工具实现批量转化, 就像常说的那样, 很多事情做起来费劲, 多半使我们的方法不对. 类似这种体力活, 我们就需要换个思路.</p><h2 id="Inkscape介绍"><a href="#Inkscape介绍" class="headerlink" title="Inkscape介绍"></a><a href="https://zh.wikipedia.org/wiki/Inkscape" target="_blank" rel="noopener">Inkscape介绍</a></h2><p><a href="https://inkscape.org/zh/download/mac-os/" target="_blank" rel="noopener">Inkscape</a>是一套向量图形编辑器，以自由软件授权发布与使用。该软件的开发目标是成为一套强力的绘图软件，且能完全遵循与支持XML、SVG及CSS等开放性的标准格式。Inkscape是一套跨平台性的应用程序，Windows、Mac OS X、Linux及类UNIX版等操作系统。</p><h3 id="Inkscape-安装"><a href="#Inkscape-安装" class="headerlink" title="Inkscape 安装"></a>Inkscape 安装</h3><h4 id="1-下载安装-0-91"><a href="#1-下载安装-0-91" class="headerlink" title="1. 下载安装(0.91)"></a>1. 下载安装(0.91)</h4><blockquote><p>务必按照以下安装步骤,  依赖于XQuartz, 需要首先安装XQuartz<br>下载</p></blockquote><ol><li>下载安装<a href="http://xquartz.macosforge.org/" target="_blank" rel="noopener">XQuartz</a></li><li>重启电脑或者登出完成 XQuartz 安装过程</li><li>下载<a href="https://inkscape.org/en/gallery/item/3896/Inkscape-0.91-1-x11-10.7-x86_64.dmg" target="_blank" rel="noopener">Inkscape.dmg</a>, 打开dmg文件, 并将Inkscape添加到Applications文件夹</li><li>运行Inkscape. 将会弹出一个提示框, 询问X11的安装目录. 请将其指向XQuartz在您Applications文件夹下的安装路径</li><li>打开X11 &gt; Preferences, 配置input 和 pasteboard :</li></ol><p><img src="https://media.inkscape.org/media/cms_page_media/328/x11pref_input.png" alt=""><br><img src="https://media.inkscape.org/media/cms_page_media/328/x11pref_pasteboard.png" alt=""></p><h3 id="Homebrew-Inkscape-0-92-1"><a href="#Homebrew-Inkscape-0-92-1" class="headerlink" title="Homebrew (Inkscape 0.92.1)"></a>Homebrew (Inkscape 0.92.1)</h3><p>确定电脑中已安装Homebrew, 在命令窗口中执行</p><blockquote><p>brew install caskformula/caskformula/inkscape</p></blockquote><p>如果过之前有用brew安装过其他版本的Inkscape, 请先执行以下命令</p><blockquote><p>brew uninstall inkscape<br>brew cleanup</p></blockquote><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><ol><li>创建一个文件 , convertSVGtoPDF.sh</li><li><p>添加以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">mkdir &quot;$PWD&quot;/pdf</span><br><span class="line">for file in $PWD/*.svg</span><br><span class="line">do</span><br><span class="line">filename=$(basename &quot;$file&quot;)</span><br><span class="line">inkscape &quot;$file&quot; -d 1200 -A &quot;$PWD&quot;/pdf/&quot;$&#123;filename%.svg&#125;.pdf&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>执行</p><blockquote><p>chmod +x convertSVGtoPDF.sh</p></blockquote></li><li><p>然后将convertSVGtoPDF.sh 放在要转化的svg文件夹根目录, 在命令行中执行</p><blockquote><p>./convertSVGtoPDF.sh</p></blockquote></li><li><p>生成的pdf就在pdf文件夹下</p></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>生成png的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">mkdir &quot;$PWD&quot;/png</span><br><span class="line">for file in $PWD/*.svg</span><br><span class="line">do</span><br><span class="line">filename=$(basename &quot;$file&quot;)</span><br><span class="line">inkscape &quot;$file&quot; -d 1200 --export-png=&quot;$PWD&quot;/png/&quot;$&#123;filename%.svg&#125;.png&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>其他操作类似</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序员都是比较懒的人, 至少我是这样, 把一个svg转成pdf, 我可以在网上找找在线转化, 三个以上, 我就不伺候了, 就要找工具实现批量转化, 就像常说的那样, 很多事情做起来费劲, 多半使我们的方法不对. 类似这种体力活, 我们就需要换个思路.&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="Technique" scheme="http://yoursite.com/categories/Technique/"/>
    
    
      <category term="svg, iOS" scheme="http://yoursite.com/tags/svg-iOS/"/>
    
  </entry>
  
</feed>
