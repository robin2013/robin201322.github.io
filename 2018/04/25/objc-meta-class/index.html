<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C 中的元类 (meta-class) · 罗宾的木屋</title><meta name="description" content="Objective-C 中的元类 (meta-class) - Robin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="罗宾的木屋"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/categories/Algorithms" target="_self" class="nav-list-link">算法</a></li><li class="nav-list-item"><a href="/categories/Technique" target="_self" class="nav-list-link">技巧</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="https://github.com/robin2013" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Objective-C 中的元类 (meta-class)</h1><div class="post-info">Apr 25, 2018</div><div class="post-content"><p>通常的开发过程中, 我们很少接触到元类的概念, 基本上用不到, 但是, 对于Objective-C运行时的理解上,是需要对元类有所了解的.</p>
<p>OC源于C语言, 同时结合了SmallTalk的面向语言的特性, 最终变成我们今天看到的样子, 关于OC 和Smalltalk的关系, 可以看<a href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/" target="_blank" rel="noopener">这里</a>, OC的底层还是C, 只是在编译的时候, 编译器会把我们的OC语法重新转换成C的语法.</p>
<p>C是静态语言, 换言之, 调用什么方法是在编译阶段确定的.<br>OC是动态语言, 编译工程只能确定要发送的消息, 具体如何响应, 需要由运行时检查相关实例所属的类, 并在方法列表中检索出具体实现, 然后做出响应.(这就是OC的消息发送机制, 为什么叫发消息, 不叫调函数)</p>
<p>###在运行时创建一个类<br>我们用运行时创建一个NSError的子类, 并添加一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class newClass =</span><br><span class="line">    objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0);</span><br><span class="line">class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;);</span><br><span class="line">objc_registerClassPair(newClass);</span><br></pre></td></tr></table></figure></p>
<p>并添加一个<code>ReportFunction</code>的函数作为实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void ReportFunction(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]);</span><br><span class="line"></span><br><span class="line">    Class currentClass = [self class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中, 用运行时创建一个类, 总共用了三步:</p>
<ol>
<li>为”class pair”（类对）分配空间（使用 objc_allocateClassPair ）</li>
<li>添加类中所需的方法和变量（这里使用 class_addMethod 添加了一个方法）</li>
<li>注册这个类使其能够被使用（使用 objc_registerClassPair ）</li>
</ol>
<blockquote>
<p>之所以叫类对, 原因是返回一个类, 同时创建相关元类, 只是不用返回</p>
</blockquote>
<p>###数据结果如何才能成为一个对象<br>每个对象都必须有所属的类, 这是面向对象概念的基本原则(万物皆对象), 对于OC页同样适用. 任何数据结构只要包含一个正确指向类的指针皆可称谓对象.<br>在OC中, 一个对象的类是有一个<code>isa</code>指针确定的. <code>isa</code>指向实例的类.</p>
<p>OC中最根本的对象定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">@interface Object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>换言之, 所有以一个指向<code>isa_t</code>指针开始的数据结构, 都可以认为是<code>objc_object</code></p>
<blockquote>
<p>现在isa的类型变成了 isa_t 类型而不是 Class类型, 所里这里直接采用最新的定义方式</p>
</blockquote>
<p>OC中的对象一个重要特点就是可以向他们发送消息(不是直接调用他们的函数):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@&quot;stringValue&quot;</span><br><span class="line">    writeToFile:@&quot;/file.txt&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL];</span><br></pre></td></tr></table></figure></p>
<p>当你发送一个消息给OC的对象时（就像这里的 NSCFString），运行时会根据对象的isa指针获取到对象的类（这里是 NSCFString 类）。类包含了一串方法能够被这个类的所有实例对象使用，并且有一个 superclass的指针来查找继承链中的方法。运行时在类和父类的方法列表中查找能够匹配这个消息的 selector（在上面的例子中，是在 NSString 类中的 writeToFile:atomically:encoding:error 方法）。然后运行时唤起这个方法的实现(IMP)。</p>
<p><strong>重点是<code>Class</code>定义了你可以向其对象发送的消息</strong></p>
<h3 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h3><p>此刻, 你应该可以理解在OC中<code>Class</code>其实也是一种对象, 这就意味着你可以像<code>Class</code>发送消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStringEncoding defaultStringEncoding = [NSString defaultStringEncoding];</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中, <code>defaultStringEncoding</code>就是发送给<code>NSString</code>class的消息<br>由于<code>Class</code>是一种对象, 意味着<code>Class</code>必然包含一个<code>isa</code>指针,以便于和<code>objc_object</code>兼容,objc_class的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了调用一个类方法, 类的<code>isa</code>必须指向一个<code>Class</code>数据结构, 并且这个类结构必须包含一个方法列表使我们能够对类使用。<br>这就引导出元类的定义： 元类是一个类对象的类。</p>
<p>简而言之：<br>当你向一个对象发送一条消息的时候，运行时会在对象的类的方法列表中查找这条消息是否存在。<br>当你向一个类发送一条消息的时候，运行时会在类的元类的方法列表中查找这条消息是否存在。</p>
<p>元类的存在是必需的，因为他存储了一个类的所有类方法。每个类的元类都是独一无二的，因为每个类都有一系列独特的类方法。</p>
<p>什么是元类的类</p>
<p>元类，和类一样，也是一个对象。这表示你能够对元类调用方法。自然的，这表示他必须也有一个类指针。</p>
<p>所有元类使用基类的元类（即继承链顶端的类的元类）作为他们的类，而所有类的基类都是 NSObject（大多数类是这样的），所以大多数元类使用 NSObject 的元类作为他的类。</p>
<p>根据规则所有元类使用基类的元类作为他们的类，那么基类的元类就是他自己的类（他们的isa指针指向了自己）。这表明NSObject的元类的指针指向的是他自己（他是一个他自己的实例）。</p>
<p>继承类和元类</p>
<p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。<br>这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己。<br>这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p>
<p>所有实例、类和元类都在 NSObject 的层级下，这表明所有 NSObject 的实例方法都能够被使用，同样的，对类以及元类来说，所有 NSObject 的类方法也是有效的。<br><img src="https://upload-images.jianshu.io/upload_images/1839216-afaaf3d695470e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625" alt=""></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>稍微修改上边的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self makeClass];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)makeClass &#123;</span><br><span class="line">    Class newClass =</span><br><span class="line">    objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0);</span><br><span class="line">    class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;);</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">    id instanceOfNewClass =</span><br><span class="line">    [[newClass alloc] initWithDomain:@&quot;someDomain&quot; code:0 userInfo:nil];</span><br><span class="line">    [instanceOfNewClass performSelector:@selector(report)];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ReportFunction(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;This object is %p.&quot;, self);</span><br><span class="line">    NSLog(@&quot;%@ Class is %@, and super is %@.&quot;,object_getClass(self), [self class], [self superclass]);</span><br><span class="line"></span><br><span class="line">    Class currentClass = [self class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %p ---  class %@&quot;, i, currentClass, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]);</span><br><span class="line">    NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>获取一个对象的类：ReportFunction 使用 object_getClass 来跟踪 isa 指针，因为 isa 指针是类结构中被保护的成员（你不能直接访问对象的 isa 指针）。ReportFunction 没有使用一个类方法来做这些，是因为对一个类对象调用类方法不会返回元类，取而代之的是又返回了这个类（所以 [NSString class] 将返回 NSString 的类而不是 NSString 元类）。</p>
</blockquote>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">This object is 0x6000004499f0.</span><br><span class="line">RuntimeErrorSubclass Class is RuntimeErrorSubclass, and super is NSError.</span><br><span class="line">Following the isa pointer 1 times gives 0x600000449a50 ---  class RuntimeErrorSubclass</span><br><span class="line">Following the isa pointer 2 times gives 0x600000449db0 ---  class RuntimeErrorSubclass</span><br><span class="line">Following the isa pointer 3 times gives 0x101d41e58 ---  class NSObject</span><br><span class="line">Following the isa pointer 4 times gives 0x101d41e58 ---  class NSObject</span><br><span class="line">NSObject&apos;s class is 0x101d41ea8</span><br><span class="line">NSObject&apos;s meta class is 0x101d41e58</span><br></pre></td></tr></table></figure></p>
<p>看一下isa所指向的地址的值：</p>
<ul>
<li>instanceOfNewClass实例对象的地址： 0x6000004499f0</li>
<li>instanceOfNewClass 的类的地址： 0x600000449a50</li>
<li>RuntimeErrorSubclass 的元类的地址： 0x600000449db0</li>
<li>RuntimeErrorSubclass 的元类的类的地址： 0x101d41e58 (即NSObject的元类地址)</li>
<li>NSObject 元类的类就是 NSObject 的元类（地址相同）</li>
</ul>
<p>地址的值并不是主要的，但是他体现了之前我们所描述的从类到元类，再到NSObject元类的整个进度。</p>
<p>总结：</p>
<ul>
<li><p>元类是一个类对象的类。每一个类有他自己独一无二的元类（因为每个类能够有自己独一无二的方法列表）。这就意味着类对象的类并不是和他们一样的类。</p>
</li>
<li><p>元类能确保类对象有所有底层类的实例和类方法，中间加上所有自己的类方法。所有类继承自NSObject，这意味着NSObject所有的实例和协议方法为所有类（和元类）对象都定义了。</p>
</li>
<li><p>所有元类使用基类的元类（NSObject 元类）来作为他们的类，包括只在运行时自定义的类的元类。</p>
</li>
</ul>
<p>参考: <a href="https://www.jianshu.com/p/79b06fabb459" target="_blank" rel="noopener">浅谈 Objective-C 中的元类 (meta-class)</a></p>
<p><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html#" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></p>
<blockquote>
<p>原谅我的懒惰, 有些文字是直接拷贝的</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/07/ios-install-ipa/" class="prev">上一篇</a><a href="/2018/04/24/len-of-substring-without-repeate/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Robin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>